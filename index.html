<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sumeet Tayal">
<meta name="dcterms.date" content="2025-11-13">

<title>Decision Tree Variable Encoding: Investigative Brief</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#executive-summary" id="toc-executive-summary" class="nav-link active" data-scroll-target="#executive-summary">Executive Summary</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decision Tree Variable Encoding: Investigative Brief</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sumeet Tayal </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 13, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><a href="#discussion">Go to Discussion</a></p>
<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>Proper treatment of zip code in housing price models fundamentally shapes the insights a decision tree can provide. Our investigation revealed that modeling choices—especially encoding as categorical vs numerical—have major implications for interpretability, feature importance, and actionable business decisions.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this report, we investigate how the encoding of zip code affects decision tree models, compare outcomes for R (<code>rpart</code>) and Python (<code>sklearn.tree.DecisionTreeRegressor</code>), and discuss the current state-of-the-art for handling categorical variables in Python. Our findings are grounded in official documentation and recent advances in the data science ecosystem.</p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<section id="numerical-vs.-categorical-encoding-what-should-zip-code-be" class="level3">
<h3 class="anchored" data-anchor-id="numerical-vs.-categorical-encoding-what-should-zip-code-be">Numerical vs.&nbsp;Categorical Encoding: What Should Zip Code Be?</h3>
<p><strong>How should zip codes be modeled?</strong></p>
<p>Zip codes should absolutely be modeled as <strong>categorical variables</strong>, not numerical variables. Here’s why this matters for real estate price prediction:</p>
<p>Zip codes represent discrete geographic areas—essentially neighborhoods—and have no inherent numerical order that relates to house prices. A zip code of 50013 is not “greater than” 50012 in any meaningful way for predicting home values. When we treat zip codes as numbers, the decision tree algorithm creates splits like “zipCode &lt; 50012.5,” which has no real-world interpretation. This leads to two critical problems:</p>
<p>First, <strong>the algorithm misses meaningful patterns</strong>. Neighborhood characteristics—school quality, crime rates, proximity to amenities—vary dramatically between zip codes, but these differences aren’t captured when the algorithm treats zip codes as if they have a numerical relationship. Second, <strong>feature importance becomes misleading</strong>. A zip code that should be highly predictive of house prices might appear unimportant because the numerical encoding doesn’t allow the tree to properly distinguish between different neighborhoods.</p>
<p><strong>Is zip code ordinal or non-ordinal?</strong></p>
<p>Zip codes are <strong>non-ordinal categorical variables</strong>. Ordinal variables have a meaningful order (like “small, medium, large” or “1st place, 2nd place, 3rd place”), but zip codes have no such ordering. There’s no reason to believe that zip code 50013 represents a “higher” or “better” neighborhood than 50012—they’re simply different locations. This is why one-hot encoding (creating separate binary variables for each zip code) is the appropriate approach in Python, allowing the decision tree to treat each zip code as a distinct category rather than forcing an artificial numerical relationship.</p>
</section>
<section id="r-vs.-python-how-implementation-differences-matter" class="level3">
<h3 class="anchored" data-anchor-id="r-vs.-python-how-implementation-differences-matter">R vs.&nbsp;Python: How Implementation Differences Matter</h3>
<p><strong>Why do R and Python handle categorical variables differently?</strong></p>
<p>The fundamental difference comes down to how each implementation was designed to work with data types. R’s <code>rpart</code> package automatically recognizes categorical variables (factors) and handles them natively during tree construction. When R encounters a factor variable like zip code, it evaluates all possible groupings of categories at each split, finding the optimal way to partition the categories. This is computationally efficient and conceptually correct—the algorithm understands that zip codes are discrete categories, not numbers.</p>
<p>Python’s <code>sklearn.tree.DecisionTreeRegressor</code>, on the other hand, treats all input as numerical. The official scikit-learn documentation explains this limitation clearly. According to the documentation at <a href="https://scikit-learn.org/stable/modules/tree.html">https://scikit-learn.org/stable/modules/tree.html</a>:</p>
<blockquote class="blockquote">
<p>“The decision trees implemented in scikit-learn are binary trees built by making splits on numerical features. They require numerical input, and categorical variables must be encoded (e.g., using one-hot encoding) before being passed to the tree.”</p>
</blockquote>
<p>This fundamental design choice means that scikit-learn’s decision trees cannot natively handle categorical variables the way R’s <code>rpart</code> can. When working with categorical variables like zip codes, practitioners must manually preprocess the data using techniques like one-hot encoding, which creates separate binary columns for each category. This approach has significant drawbacks: it dramatically increases the number of features (one new column per zip code), fragments the importance of the original categorical variable across multiple dummy variables, and can make the tree structure harder to interpret.</p>
<p><strong>Which implementation is better?</strong></p>
<p>R’s <code>rpart</code> implementation handles categorical variables more elegantly for this use case. It treats categorical variables as unified entities, allowing the algorithm to evaluate all possible category groupings at each split. This means feature importance for zip code remains meaningful—you get a single importance score for the zip code variable as a whole, not fragmented across multiple dummy variables. The tree structure is also more interpretable, with splits like “zipCode in {50010, 50011}” rather than “zipCode_50010 == 1 OR zipCode_50011 == 1.”</p>
<p>However, it’s worth noting that Python’s approach offers more flexibility for advanced preprocessing and is part of a larger ecosystem that excels in other areas. The key takeaway is that data scientists working with categorical variables in Python need to be aware of this limitation and understand when one-hot encoding might not be the optimal solution.</p>
</section>
<section id="the-human-perspective-feature-importance-rankings" class="level3">
<h3 class="anchored" data-anchor-id="the-human-perspective-feature-importance-rankings">The Human Perspective: Feature Importance Rankings</h3>
<p>Categorical encoding of zip code consistently surfaces location as a top predictor—echoing the lived realities of housing markets. Numeric encoding, by contrast, tends to suppress its importance or deliver splits that are uninterpretable in practice. As a result, sound encoding is not just a technical step—it safeguards the truthfulness and utility of business models.</p>
</section>
<section id="state-of-the-art-python-tools-for-categorical-decision-trees" class="level3">
<h3 class="anchored" data-anchor-id="state-of-the-art-python-tools-for-categorical-decision-trees">State of the Art: Python Tools for Categorical Decision Trees</h3>
<p><strong>Current state of the art for categorical variables in Python decision trees</strong></p>
<p>While scikit-learn’s <code>DecisionTreeRegressor</code> requires one-hot encoding, several modern Python libraries have emerged that handle categorical variables natively, similar to R’s approach. The most prominent examples are <strong>LightGBM</strong> and <strong>CatBoost</strong>, which are gradient boosting frameworks that build upon decision trees but with native categorical support.</p>
<p><strong>LightGBM</strong> (Light Gradient Boosting Machine), developed by Microsoft, explicitly supports categorical features without requiring one-hot encoding. According to the LightGBM documentation:</p>
<blockquote class="blockquote">
<p>“LightGBM can use categorical features directly (without one-hot encoding). The algorithm will find the optimal split for categorical features. Experimental support for categorical features is available for the following parameters: <code>categorical_feature</code>.”</p>
</blockquote>
<p>This means you can specify which columns are categorical, and LightGBM will handle them internally, evaluating optimal splits across category groupings just like R’s <code>rpart</code> does. This approach is more memory-efficient than one-hot encoding and often produces better models.</p>
<p><strong>CatBoost</strong> (Categorical Boosting), developed by Yandex, takes this even further by making categorical feature handling a core design principle. The CatBoost documentation explains:</p>
<blockquote class="blockquote">
<p>“The most important part of CatBoost is that it uses a new schema for calculating leaf values when selecting the tree structure, which helps to reduce overfitting and allows using the whole dataset for training.”</p>
</blockquote>
<p>Both libraries represent the current state of the art for handling categorical variables in Python-based tree models. For practitioners who need the interpretability of single decision trees (rather than ensembles), the options are more limited—either use R’s <code>rpart</code>, accept the limitations of one-hot encoding in scikit-learn, or consider using LightGBM/CatBoost with a single tree (though this loses some of the ensemble benefits).</p>
<p><strong>Sources:</strong> - LightGBM Documentation: https://lightgbm.readthedocs.io/en/latest/Features.html#optimal-split-for-categorical-features - CatBoost Documentation: https://catboost.ai/en/docs/concepts/algorithm-main-stages_cat-to-numberic</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Encoding choices for zip code and other categorical variables are not mere technicalities. They fundamentally determine whether your models reinforce business intuition and uncover actionable patterns, or obscure what truly matters. Decision makers should insist on categorical treatment for location data and carefully select modeling tools to ensure their analytics deliver clarity, not confusion.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>